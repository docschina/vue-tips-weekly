# ğŸ”¥ (#70) Configuration driven templates

July 2022

Heyo!

æˆ‘ä»¬åœ¨ç››å¤äº†ã€‚

æˆ‘è¦åœ¨æˆ‘çš„ 2015 æ¬¾ MBP çƒ§ä¼¤æˆ‘çš„è…¿ä¹‹å‰å†™å®Œå‘¨åˆŠã€‚

ä½†æ¯”èµ·é˜³å…‰å’Œç©ºæ°”æ˜¯å€¼å¾—çš„ã€‚

é ç€ç©ºè°ƒï¼Œæˆ‘æ‰èƒ½åœ¨å¦‚æ­¤æ½®æ¹¿ç‚çƒ­çš„æ™šä¸Šç¡è§‰ã€‚

æˆ‘çš„ç©ºè°ƒå·²ç»è¶…è¿‡ 30 å¹´å†å²äº†ï¼Œçœ‹èµ·æ¥è¿˜èƒ½å†ä½¿ç”¨ 25 å¹´ã€‚

ç©ºè°ƒè¿è¡Œèµ·æ¥å™ªå£°å¾ˆå¤§ï¼Œä½†å¹´å¤ä¸€å¹´è¿˜èƒ½æŒç»­å·¥ä½œç€ã€‚

å“ˆå“ˆï¼Œæˆ‘çŸ¥é“ä½ å¹¶ä¸å…³å¿ƒæˆ‘çš„ç©ºè°ƒã€‚

æ¥ä¸‹æ¥å¼€å§‹å‘¨åˆŠå†…å®¹ã€‚

â€”Michael

## ğŸ”¥ Ref vs. Reactive

åœ¨ä½¿ç”¨ `composition API` çš„æ—¶å€™ï¼Œç”¨ `ref` å¥½è¿˜æ˜¯ `reactive` æ›´å¥½ï¼Ÿ

è¿™é‡Œåˆ—ä¸¾ä¸€äº› `ref` æ¯” `reactive` æœ‰ä¼˜åŠ¿çš„åœ°æ–¹ã€‚

ä½¿ç”¨ `ref` åŒ…è£¹ js å¯¹è±¡ï¼ŒåŒæ—¶å¯¹æ¯” `reactive` å’Œæ™®é€šå¯¹è±¡çš„ä½¿ç”¨åœºæ™¯ï¼ŒåŒºåˆ«æ˜¾è€Œæ˜“è§ï¼š

```javascript
// I can expect this ref to update reactively
if (burger.value.lettuce) {
  // ...
}

// I have no clue if this value is reactive
if (burger.lettuce) {
  // ...
}
```

ä½¿ç”¨ `watch` æ–¹æ³•æ—¶ï¼Œ`ref` ä¼šè‡ªåŠ¨è§£æ„ï¼Œéå¸¸æ˜“ç”¨ï¼š

```javascript
// Ref
const refBurger = ref({ lettuce: true });
watch(
  // Not much, but it's a bit simpler to work with
  refBurger,
  () => console.log("The burger has changed"),
  { deep: true }
);

// Reactive
const reactiveBurger = reactive({ lettuce: true });
watch(
  () => burger,
  () => console.log("The burger has changed"),
  { deep: true }
);
```

ä½¿ç”¨ `ref` è¿˜æœ‰ä¸€ä¸ªä¼˜ç‚¹ï¼Œä½ å¯ä»¥åœ¨ `ref` ä¸­æ”¾å…¥ `reactive` å¯¹è±¡ã€‚è¿™æ ·å¯ä»¥ä»»æ„ç»„åˆ `reactive` å¯¹è±¡ï¼Œåº•å±‚è¿˜æ˜¯ä½¿ç”¨ `ref`ï¼š

```javascript
const lettuce = ref(true);
const burger = reactive({
  // æŠŠ ref å˜æˆå±æ€§
  lettuce,
});

// ç›´æ¥ç›‘å¬ reactive å¯¹è±¡
watchEffect(() => console.log(burger.lettuce));

// ä¹Ÿå¯ä»¥ç›´æ¥ç›‘å¬ ref
watch(lettuce, () => console.log("lettuce has changed"));

setTimeout(() => {
  // æ›´æ–° ref çš„å€¼ï¼Œä¼šè‡ªåŠ¨è§¦å‘æ‰€æœ‰çš„ watchers
  lettuce.value = false;
}, 500);
```

## ğŸ”¥ é…ç½®é©±åŠ¨æ¨¡æ¿

æˆ‘ç®€åŒ–æ¨¡æ¿çš„ä¸€ä¸ªå¸¸ç”¨æ–¹å¼æ˜¯**é…ç½®é©±åŠ¨**ã€‚

æˆ‘ä¸ä¼šåƒè¿™æ ·é‡å¤ç¼–å†™æ¨¡æ¿ï¼š

```html
<template>
  <div>
    <menuitem @click="openContact"> Open Contact </menuitem>
    <menuitem @click="createContact"> Create Contact </menuitem>
    <menuitem @click="sendEmail"> Send Email </menuitem>
    <menuitem @click="resetSystem" danger> Reset </menuitem>
  </div>
</template>
```

é€šå¸¸ä¼šé‡æ„æˆé€šè¿‡é…ç½®é¡¹æ¥é©±åŠ¨æ¸²æŸ“ï¼š

```html
<template>
  <div>
    <menuitem
      v-for="item in menuItems"
      :key="item.text"
      :danger="item.danger"
      @click="item.action"
    >
      {{ item.text }}
    </menuitem>
  </div>
</template>
```

```html
<script setup>
  const openContact = () => {
    /* ... */
  };
  const createContact = () => {
    /* ... */
  };
  const sendEmail = () => {
    /* ... */
  };
  const resetSystem = () => {
    /* ... */
  };

  const menuItems = [
    {
      text: "Open Contact",
      action: openContact,
    },
    {
      text: "Create Contact",
      action: createContact,
    },
    {
      text: "Send Email",
      action: sendEmail,
    },
    {
      text: "Reset System",
      action: resetSystem,
      danger: true,
    },
  ];
</script>
```

æˆ‘ä»¬æ²¡æœ‰å‡å°‘ä»£ç ï¼Œä½†è®©ä»£ç æ›´ç®€æ´äº†ï¼š

- **é…ç½®é¡¹æ›´æ˜“è¯»** â€” Reading code is complicated because you have to figure out what the logic is doing, but configuration is very straightforward to understand.
- **æ›´å°‘çš„é€»è¾‘æ„å‘³ç€æ›´å°‘çš„ bug** â€” The config above is just a boring array with some objects. It's pretty simple, so it's unlikely that bugs would come from there.
- **åŠ¨æ€ç»„ä»¶ä¼šæ›´çµæ´»** â€” Because we've made this menu component dynamically render out the different menu items, we gain tremendous flexibility.

[å…³äºè¿™ä¸ªè§‚ç‚¹](http://michaelnthiessen.com/reducing-redundant-repetition)ï¼Œæˆ‘å†™äº†è¿™ç¯‡æ–‡ç« 

## ğŸ“œ ç¼–å†™è‡ªå·±çš„ Vue.js

ä¸€ä¸ªå¤§å®¶éƒ½æ„ŸåŒèº«å—çš„æƒè¡¡é—®é¢˜ï¼Œæ˜¯ä½¿ç”¨ç°æˆçš„è§£å†³æ–¹æ¡ˆï¼Œè¿˜æ˜¯è‡ªå·±é‡æ–°å®ç°ä¸€ä¸ªæ–¹æ¡ˆï¼Ÿ

[æˆ‘å†™äº†ä¸€ä¸ªè‡ªå·±çš„ Vue.js](https://www.dopefly.com/techblog/405/I-Wrote-My-Own-Vue-js)

## ğŸ’¬ Chaos

â€œè‡ªåŠ¨åŒ–çš„æ··ä¹±ä¼šè®©æ··ä¹±æ›´å¿«å‘ç”Ÿã€‚â€ â€” Mark Fewster

## ğŸ§  é—´éš”é‡å¤ï¼šå¾ªç¯çš„ç›®çš„æ˜¯ä»€ä¹ˆï¼Ÿ

**The best way to commit something to long-term memory is to periodically review it, gradually increasing the time between reviews ğŸ‘¨â€ğŸ”¬**

**Actually remembering these tips is much more useful than just a quick distraction, so here's a tip from a couple weeks ago to jog your memory.**

I always forget this, so this tip is mostly for me â€” hopefully, I won't have to keep looking this up!

We have 3 types of `for` loops in Javascript:

1. `for...in`
2. `for...of`
3. `for`

But how do you know which one to use?

For iterating through **properties** of an object, use `for...in`:

```javascript
const numbers = {
  one: 1,
  two: 2,
  three: 3,
};

// We get the properties of the object, not the values
for (const number in numbers) {
  console.log(number);
}

// Prints: 'one' 'two' 'three'
```

Items in a **list** (also called an iterable object) like an Array or Set, we use `for...of`:

```javascript
const numbers = ["one", "two", "three"];

// We get each of the elements in the Array
for (const number of numbers) {
  console.log(number);
}

// Prints: 'one' 'two' 'three'
```

You _can_ use `for...in` with an Array since all the indices are just the object's properties. But you may not get them in the correct order, and you'll also get any other properties the Array has :/

And you know how to use a regular old `for` loop, which lets you have a lot more control with some extra typing.

_p.s. I also have two courses: [Reusable Components](https://michaelnthiessen.com/reusable-components) and [Clean Components](https://michaelnthiessen.com/clean-components)_

## æ¥æº

https://michaelnthiessen.com/weekly-070-july-20/

---
title: "🔥 (#76) I have an announcement..."
head:
  - - link
    - rel: canonical
      href: https://michaelnthiessen.com/weekly-076-august-31/
---

# 🔥 (#76) I have an announcement...

August 2022

Hey!

I've got a big announcement for you today:

**I'm your instructor for Mastering Nuxt 3!**

(but don't tell anyone, it hasn't been officially announced yet)

Mastering Nuxt is the _official_ course for Nuxt, created in partnership with VueSchool and Nuxt Labs (the creators of Nuxt).

We're creating an entirely new course to teach you how to build real-world full-stack apps using Nuxt 3. It will be released in the next few months, and I'll be sharing some more details with you in the meantime.

It's going to be epic!

You might even start to see some Nuxt-related tips here and there...

—Michael

## 🔥 Improve reusability by converting template props into slots

One kind of prop, a template prop, can be directly converted into slots without very much work.

This makes your component [more reusable](https://michaelnthiessen.com/slots-are-better-than-props/).

The `text` prop here is a template prop, because it is only ever used in the template:

```html
<template>
  <button @click="$emit('click')">{{ text }}</button>
</template>
```

```javascript
export default {
  name: "Button",
  props: {
    text: {
      type: String,
      required: true,
    },
  },
};
```

It doesn't get used in any calculations or passed as a prop anywhere. Instead, it just gets directly interpolated and rendered to the page.

These props can be directly replaced with slots:

```html
<template>
  <button @click="$emit('click')">
    <slot />
  </button>
</template>
```

```javascript
export default {
  name: "Button",
};
```

This sort of cleans up the code, but more importantly, it allows us to be more flexible with how the component can be used.

With a prop we have to use the component like this:

```html
<button text="Click me" @click="handleClick" />
```

But with a slot, we can add in whatever we want:

```html
<button @click="handleClick">Click on <strong>this</strong> button</button>
```

## 🔥 Flexible Arguments

Sometimes we have a `ref` that we want to use with our composable. Sometimes we just have the raw data.

Wouldn’t it be nice if it didn’t matter what we already had? Then we could use our composables and it would just _work_?

Here’s an example using the `useTitle` composable from VueUse:

```javascript
// We have a ref already
const titleRef = ref("This is the title of the page");
useTitle(titleRef);

// We just have the string
const title = "This is the title of the page";
const titleRef = useTitle(title);
```

We can do this by implementing the Flexible Arguments pattern:

```javascript
export function useTitle(maybeRef) {
  const titleRef = ref(maybeRef);

  // Use titleRef in the composable
}
```

The `ref` function will either create a `ref` for us, or return a `ref` if we give it one.

This means that we can pass it either type and we know we’ll get a ref back.

The opposite is true with the `unref` function. If we need to use a raw primitive value rather than a `ref` in our composable, we can use `unref` to achieve a similar result.

```javascript
export function useTitle(maybeRef) {
  const titleString = unref(maybeRef);

  // Use titleString in the composable
}
```

## 📜 The Vite Ecosystem

Vite has taken web development tooling to a new level.

This article explores all of the different tools Vite uses and interacts with, and shows just how much it affects the web development community.

It's very cool to see a project that started out in Vue-land gain wide adoption like this!

Read it here: [The Vite Ecosystem](https://patak.dev/vite/ecosystem.html)

## 💬 Things

"Things aren’t always #000000 and #FFFFFF." —`undefined`

## 🧠 Spaced-repetition: Special CSS pseudo-selectors in Vue

**The best way to commit something to long-term memory is to periodically review it, gradually increasing the time between reviews 👨‍🔬**

**Actually remembering these tips is much more useful than just a quick distraction, so here's a tip from a couple weeks ago to jog your memory.**

If you want some styles to apply specifically to slot content, you can do that with the `:slotted` pseudo-selector:

```html
<style scoped>
  /* Add margin to <p> tags within the slot */
  :slotted(p) {
    margin: 15px 5px;
  }
</style>
```

You can also use `:global` to have styles apply to global scope, even within the `<style scoped>` block:

```html
<style scoped>
  :global(body) {
    margin: 0;
    padding: 0;
    font-family: sans-serif;
  }
</style>
```

Of course, if you have lots of global styles you want to add, it's probably easier to just add a second `<style>` block:

```html
<style scoped>
  /* Add margin to <p> tags within the slot */
  :slotted(p) {
    margin: 15px 5px;
  }
</style>

<style>
  body {
    margin: 0;
    padding: 0;
    font-family: sans-serif;
  }
</style>
```

Check out [the docs](https://v3.vuejs.org/api/sfc-style.html#slotted-selectors) for more info.

_p.s. I also have two courses: [Reusable Components](https://michaelnthiessen.com/reusable-components) and [Clean Components](https://michaelnthiessen.com/clean-components)_

## 来源

原文 https://michaelnthiessen.com/weekly-076-august-31/

本作品采用[知识共享署名-相同方式共享 4.0 国际许可协议](http://creativecommons.org/licenses/by-sa/4.0/)进行许可。

---
title: "🔥 (#80) Component Metadata"
head:
  - - link
    - rel: canonical
      href: https://michaelnthiessen.com/weekly-080-september-28/
---

# 🔥 (#80) Component Metadata

2022 年 9 月

Hey!

本周我开始录制《Mastering Nuxt 3》的第一批视频。

我已经有一段时间没有做过出镜视频了，所以我需要一些时间来找回我的节奏，但到目前为止还不错！

请阅读这些 tips，生活愉快！

—Michael

## 🔥 不要覆盖组件 CSS

从组件外部修改组件的样式很轻松方便，如果你需要的只是一个小小的修改，看起来似乎是没有问题的，但事实并非如此。

比如你有一个普通的蓝色按钮，在某些情况下你需要改成绿色按钮。你可以这样在父级组件覆盖颜色：

```html
<template>
  <button class="green">Make this button green</button>
</template>

<style>
  .green.button {
    background: green;
  }
</style>
```

代码是能运行的，但是效果非常容易收到影响。

如果类名改变了怎么办？

如果组件的 HTML 结构修改了怎么办？

其他人如果需要修改这个组件，可能不知道组件的背景色被覆盖了。

相反，我们可以只扩展按钮组件的功能。这样，我们将修改按钮的所有代码保留在按钮组件中。

在这里，我们可以向按钮组件添加一个 `is green` 属性：

```html
<template>
  <button is-green>Make this button green</button>
</template>

<style>
  /* No extra styles needed! */
</style>
```

我创建了一个示例，展示了原始组件和添加了 prop 的新组件: [https://codesandbox.io/s/wizardly-aryabhata-kn37d?file=/src/components/Button.vue](https://codesandbox.io/s/wizardly-aryabhata-kn37d?file=/src/components/Button.vue)。

## 🔥 Component Metadata

并不是你添加到组件中的每一个信息都是状态。例如，有时需要添加元数据，向其他组件提供更多信息。

例如，如果您希望此布局知道每个小部件应占用多少列，可以将其直接添加到组件上作为元数据：

```javascript
export default {
  name: "LiveUsersWidget",
  // Just add it as an extra property
  columns: 3,
  props: {
    // ...
  },
  data() {
    return {
      //...
    };
  },
};
```

您将在组件上找到此元数据作为属性：

```javascript
import LiveUsersWidget from "./LiveUsersWidget.vue";
const { columns } = LiveUsersWidget;
```

You can also access the metadata from within the component through the special `$options` property:

```javascript
export default {
  name: "LiveUsersWidget",
  columns: 3,
  created() {
    // `$options` contains all the metadata for a component
    console.log(`Using ${this.$options.metadata} columns`);
  },
};
```

Just keep in mind that this metadata is the same for each component instance and is _not_ reactive.

Other uses for this include (but are not limited to):

- Keeping version numbers for individual components
- Custom flags for build tools to treat components differently
- Adding custom features to components beyond computed props, data, watchers, etc.
- and many more I can't think of!

See a live example here: [https://codesandbox.io/s/vue-metadata-bew9j?file=/src/App.vue](https://codesandbox.io/s/vue-metadata-bew9j?file=/src/App.vue)

## 📜 Coding Better Composables: Options Object (1/5)

I teamed up with Vue Mastery to create this series on coding better composables.

In this series we cover five different patterns.

For each, we show how you can implement it and then we see it in action with a composable from VueUse.

This first article is on using an options object to easily configure the behaviour of your composable.

Read it here: [Coding Better Composables: Options Object (1/5)](https://www.vuemastery.com/blog/coding-better-composables-1-of-5)

## 💬 Data structures

"Bad programmers worry about the code. Good programmers worry about data structures and their relationships." —Linus Torvalds

## 🧠 Spaced-repetition: Async Without Await

**The best way to commit something to long-term memory is to periodically review it, gradually increasing the time between reviews 👨‍🔬**

**Actually remembering these tips is much more useful than just a quick distraction, so here's a tip from a couple weeks ago to jog your memory.**

Using async logic with the composition API can be tricky at times.

We need to put things in the correct order, or the `await` keyword will mess things up with our reactivity.

But with the Async Without Await pattern, we don’t need to worry about all of this:

```javascript
const title = ref("Basic Title");
// We can place this async function wherever we want
const { state } = useAsyncState(fetchData());
const betterTitle = computed(() => `${title.value}!`);
```

Here’s how this works:

1. We hook up all of our refs _synchronously_
2. Updates happen _asynchronously_ in the background
3. Because of reactivity, everything “just works”

Here’s a basic sketch of what the `useAsyncState` composable from VueUse is doing to implement this:

```javascript
export default useAsyncState(promise) {
  // 1. Create state ref synchronously
  const state = ref(null);

  const execute = async () => {
    // 3. Reactivity will update this when it resolves
    state.value = await promise;
  }

  // 2. Execute promise asynchronously in the background
  execute();
  return state;
}
```

_p.s. I also have three courses: [Vue Tips Collection](https://michaelnthiessen.com/vue-tips-collection), [Reusable Components](https://michaelnthiessen.com/reusable-components) and [Clean Components](https://michaelnthiessen.com/clean-components)_

## 来源

原文 https://michaelnthiessen.com/weekly-080-september-28/

本作品采用[知识共享署名-相同方式共享 4.0 国际许可协议](http://creativecommons.org/licenses/by-sa/4.0/)进行许可。
